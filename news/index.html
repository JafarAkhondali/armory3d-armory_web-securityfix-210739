<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width"/>
  <title>Armory3d.org / News</title>

  <link rel="stylesheet" href="css/styles.css?v=1.0">
</head>

<body>


<a href="#news0516">
<h1 style="text-align:center" id="may">One Month Later</h1>
</a>

<h6 style="text-align:center">June/01/16</h6>

<p>
  <h6 style="text-align:center">Jump to<br/>
    <a href="#may_current_state">Current State</a> |
    <a href="#may_new_features">New Features</a> |
    <a href="#may_links">Links</a>
    </h6>
</p>

<p><a href="images/title.jpg"><img src="images/title.jpg" alt=""/></a></p>
<p>(Click to enlarge)</p>


<p>
<a href="#may_current_state">
<h2 id="may_current_state">Current State</h2>
</a>
</p>

<p>
It has been a month since the original <a href="http://luboslenco.com/notes/">introduction</a> of <b>game engine</b> for Blender. I did not yet manage to get <b>early version</b> out which was planned to be ready by now, nonetheless crazy amount of stuff has been implemented (which in turn prevented making everything work out of the box). To not just stay silent, a complete post detailing all the <b>new stuff</b> is up!
</p>

<p>
I got lots of feedback with lots of ideas on how to make the project <b>more useful</b> - huge <b>thank you</b> to everyone who participated. There are truly amazing people with amazing projects out there, and I hope this tool can become <b>useful to you</b>. The goal is to bring the world of real time into Blender, while keeping the <b>artist first</b>. No separate application with separate workflow and separate asset pipeline. Artist is capable to compose any game/visualization scene with <b>no interruptions</b>. One concern was the engine name, which is now being resolved. Welcome to <b>Armory</b>!
</p>

<p>
<a href="https://github.com/KTXSoftware/Kha">Kha</a> (the library this engine builds upon) solves all the low-level trouble in the most genius way. The solutions found in Kha give confidence that <b>anything is doable</b>. It is also getting <b>awesome new stuff</b> - more performance, live code/asset/shader patching, more powerful build system, built-in support for compressed texture formats, surround audio. I hope to pack a portion of those into the first release.
</p>

<p>
All the crucial renderer features <b>are ready</b> now, which should mean the <b>early release</b> is finally doable by the end of this month(duh). For starting out, the project will be <b>paid</b>. I am <b>not in favor</b> of separate paid modules or forcing any splash screens. I will keep evaluating other funding options to eventually <b>go free</b>. The project will always stay <b>open source</b>. All available documentation will also be <b>open to anyone</b>. More regular updates on this site will be coming, and I will try making it easier to follow the news.
</p>

<p>Enough rambling - if you are curious about the <b>new stuff</b> please check the images below.</p>

<p>
In case of any feedback, <b>get in touch</b>!<br/>
<a href="https://twitter.com/luboslenco">@luboslenco</a>,
<script language="JavaScript">
var user_name = "lubos.lenco";
var host_name = "gmail.com";
var link_text = user_name + "@" + host_name;
document.write("<a href='" + "mail" + "to:" + user_name + "@" + host_name + "'>" + link_text + "</a>");
</script>
</p>


<p>
<a href="#may_new_features">
<h2 id="may_new_features">New Features</h2>
</a>
</p>

<p>
Let's review all the new stuff since original introduction a month ago!
</p>

<p>
Support for <b>subsurface scattering</b> is added based on SSSS technique - <a href="http://luboslenco.com/notes/ssss/">implementation details</a>.
</p>
<p>
<iframe width="560" height="315" frameBorder="0"
src="http://www.youtube.com/embed/3kIqvqDnWt8?autoplay=0">
</iframe>
</p>

<p>
<b>Area lights</b> of polygonal shapes based on recent 'Real-Time Polygonal-Light Shading with Linearly Transformed Cosines' paper are implemented.
</p>

<p>
<iframe width="560" height="315" frameBorder="0"
src="http://www.youtube.com/embed/HZ5ZqDg6Lmk?autoplay=0">
</iframe>
</p>

<p>
Ability to use <b>ocean modifier</b>. The mesh surface is ray-traced in screen space on the GPU.ï»¿
</p>
<p>
<iframe width="560" height="315" frameBorder="0"
src="http://www.youtube.com/embed/l1hWrrfCpTw?autoplay=0">
</iframe>
</p>

<p>
The idea is of course to map everything to the <b>built-in</b> ocean modifier you know from Blender.
</p>

<p><a href="images/ocean_modifier.png"><img src="images/ocean_modifier.png" alt=""/></a></p>

<p>
Apart from games, many people got interested in <b>real time visualizations</b>.
Which leads to first <b>architecture rendering</b> test! There is no good use of textures, I believe an artist can get much more out of it.
</p>
<p>
<iframe width="560" height="315" frameBorder="0"
src="http://www.youtube.com/embed/NGQzkjCyXcE?autoplay=0">
</iframe>
</p>

<p>
While at it, <b>video textures</b> are now properly implemented <b>using nodes</b>. This will make it possible to also use video as an input for other texture slots, like <b>normals or roughness</b>.
</p>

<p><a href="images/video_tex.png"><img src="images/video_tex.png" alt=""/></a></p>

<p>
A very basic <b>toon shader</b> is implemented. The outline is not good enough and will be enhanced in the future, probably in the compositor pass.
</p>

<p><a href="images/toon.jpg"><img src="images/toon.jpg" alt=""/></a></p>

<p>
Support for <b>decals</b>!
</p>
<p><a href="images/decals.jpg"><img src="images/decals.jpg" alt=""/></a></p>

<p>
If you know how to make decals using <b>UV Project</b> modifier in Blender, the system works exactly the same. This is an important aspect as Blender users do <b>not</b> have to <b>relearn</b> anything. On the other hand, many tutorials on the UV Project Modifier are already available around. A decals example scene will be of course also provided.
</p>

<p>
Decals use the <b>same material system</b>, which makes it possible to also override roughness and metalness. On top of that, we can use things like Color Ramp together with Object Info node - this way each decal will get <b>differently colored</b> based on the values from Color Ramp.
</p>

<p>
Since we want to know exactly what we are doing during <b>shader execution</b> and do only <b>minimum</b> amount of work, a special <b>shader variant</b> gets automatically selected which includes Color Ramp. On the other hand, if no Color Ramp is used the renderer has no idea it even exists. This way we save <b>precious uniforms and shader instructions</b>.
</p>
<p><a href="images/decals_mat.png"><img src="images/decals_mat.png" alt=""/></a></p>

<p>
A very important (and difficult) part is the rendering of <b>translucent surfaces</b>. Weighted blended order independent transparency technique has been implemented to solve this.
</p>
<p><a href="images/wboit.jpg"><img src="images/wboit.jpg" alt=""/></a></p>

<p>
As always, <b>regular Cycles node</b> is used. In this case, we choose the Glass node.
</p>
<p><a href="images/nodes_glass.png"><img src="images/nodes_glass.png" alt=""/></a></p>

<p>
Since we compose render pipeline <b>using nodes</b>, you can easily modify it, completely remove it or implement a <b>different technique</b> based on your needs. There is no black box which hides the renderer steps.
</p>
<p><a href="images/translucent_nodes.png"><img src="images/translucent_nodes.png" alt=""/></a></p>

<p>
To easily simulate <b>realistic skies</b> and time of day, Hosek / Wilkie sky model is implemented.
</p>
<p><a href="images/hosek.jpg"><img src="images/hosek.jpg" alt=""/></a></p>

<p>
Just drop it into your <b>world nodes</b>! It is the same one you already use in Cycles.
</p>
<p><a href="images/hosek_nodes.png"><img src="images/hosek_nodes.png" alt=""/></a></p>

<p>
GBuffer compositing has been enhanced to easily allow <b>differently sized</b> render targets. Depth buffers are now <b>bindable</b> through nodes, and can also be <b>shared</b> among multiple render targets.
</p>
<p><a href="images/gbuffer_nodes.png"><img src="images/gbuffer_nodes.png" alt=""/></a></p>

<p>
Render pipeline now supports <b>programmable logic and branching</b>. Call functions to preprocess data for your shaders, or branch the frame composition based on <b>dynamic input</b>. You might easily lower the render target sizes when frame time goes below acceptable levels, or disable some post processing on the fly.
</p>
<p><a href="images/branch_pipe.png"><img src="images/branch_pipe.png" alt=""/></a></p>

<p>
Basics of <b>anisotropic specular</b> are added to go with Anisotropic BSDF Cycles shader node.
</p>
<p><a href="images/aniso.jpg"><img src="images/aniso.jpg" alt=""/></a><br/>
<a href="images/aniso2.jpg"><img src="images/aniso2.jpg" alt=""/></a></p>

<p>
<a href="#may_links">
<h2 id="may_links">Links</h2>
</a>
</p>

<ul>
<li><a href="http://luboslenco.com/notes">Engine intro</a></li>
<li><a href="https://www.blender.org">Blender</a></li>
<li><a href="https://github.com/KTXSoftware/Kha">Kha</a></li>
<li><a href="http://haxe.org">Haxe</a></li>
</ul>
